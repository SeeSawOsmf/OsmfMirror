<?xml version="1.0" encoding="utf-8"?>
<!--
/*****************************************************
*  
*  Copyright 2009 Akamai Technologies, Inc.  All Rights Reserved.
*  
*****************************************************
*  The contents of this file are subject to the Mozilla Public License
*  Version 1.1 (the "License"); you may not use this file except in
*  compliance with the License. You may obtain a copy of the License at
*  http://www.mozilla.org/MPL/
*   
*  Software distributed under the License is distributed on an "AS IS"
*  basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See the
*  License for the specific language governing rights and limitations
*  under the License.
*   
*  
*  The Initial Developer of the Original Code is Akamai Technologies, Inc.
*  Portions created by Akamai Technologies, Inc. are Copyright (C) 2009 Akamai 
*  Technologies, Inc. All Rights Reserved. 
*  
*****************************************************/
-->
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" layout="absolute" 
	xmlns:players="com.adobe.strobe.players.*" applicationComplete="initApp()"
	backgroundColor="#000000" xmlns:examples="org.openvideoplayer.examples.*">

	<mx:Style source="DynamicStreamingSample.css" />
	<mx:Script>
		<![CDATA[
			import org.openvideoplayer.traits.IAudible;
			import org.openvideoplayer.examples.Compositions;
			import mx.events.StateChangeEvent;
			import mx.controls.sliderClasses.Slider;
			import mx.events.DropdownEvent;		
			import mx.events.SliderEvent;
			import mx.controls.Alert;
			import mx.core.UIComponent;
			
			import org.openvideoplayer.parsers.SMILParser;
			import org.openvideoplayer.plugin.PluginClassResource;

			import org.openvideoplayer.traits.MediaTraitType;
			import org.openvideoplayer.traits.LoadState;
			import org.openvideoplayer.traits.ILoadable;
			import org.openvideoplayer.traits.MediaTraitType;			
			import org.openvideoplayer.traits.ISpatial;
			import org.openvideoplayer.traits.ISwitchable;
			import org.openvideoplayer.traits.IViewable;

			import org.openvideoplayer.events.*;

			import org.openvideoplayer.media.MediaInfo;
			import org.openvideoplayer.media.MediaElement;
			import org.openvideoplayer.media.IMediaResource;
			import org.openvideoplayer.media.URLResource;			
			import org.openvideoplayer.media.IURLResource;

			import org.openvideoplayer.video.VideoElement;
			
			import org.openvideoplayer.utils.*;
			
			import org.openvideoplayer.net.dynamicstreaming.DynamicStreamingNetLoader;
			import org.openvideoplayer.net.dynamicstreaming.DynamicStreamingResource;
			
			private var sliderDragging:Boolean;
			private var waitForSeek:Boolean;
			private var currentDebugLineNo:int;
			
			private static const DEFAULT_PROGRESS_DELAY:uint = 100;
			private static const MAX_VIDEO_WIDTH:int = 640;
			private static const MAX_VIDEO_HEIGHT:int = 360;		
			
			private var _smilParser:SMILParser;
			
			[Bindable]
			private var _smilFileLoadState:String = "Not Loaded";
			
			[Bindable]
			private var _switchable:ISwitchable;
			
			[Bindable]
			private var _isAutoSwitchable:Boolean = true;
			
			[Bindable]
			private var _autoswitchBtnLabel:String = "Manual";
			
			private var _viewable:IViewable;
			
			private function initApp():void
			{
				wrapper.mediaPlayer.addEventListener(DimensionChangeEvent.DIMENSION_CHANGE, onDimensionChange);		
				wrapper.mediaPlayer.addEventListener(DurationChangeEvent.DURATION_CHANGE, onDurationChange);	
				wrapper.mediaPlayer.addEventListener(PlayheadChangeEvent.PLAYHEAD_CHANGE, onPlayheadChange);
				wrapper.mediaPlayer.addEventListener(SeekingChangeEvent.SEEKING_CHANGE, onSeekingChange);
				
				wrapper.mediaPlayer.playheadUpdateInterval = DEFAULT_PROGRESS_DELAY;
								
				sliderDragging = false;
				waitForSeek = false;
				clearDebugText();
			}
			
			private function onLoadableStateChange(event:LoadableStateChangeEvent):void
			{
				debug("onLoadableStateChange() - newState="+event.newState+", oldState="+event.oldState);
				switch (event.newState)
				{
					case LoadState.LOADED:
						_smilFileLoadState = "Loaded";
						_switchable = wrapper.element.getTrait(MediaTraitType.SWITCHABLE) as ISwitchable;

						if (_switchable != null)
						{
							_switchable.addEventListener(SwitchingChangeEvent.SWITCHING_CHANGE, onSwitchingChange);
						}
						wrapper.mediaPlayer.volume = .5;
														
						_viewable = wrapper.element.getTrait(MediaTraitType.VIEWABLE) as IViewable;		
						updateSwitchingControls();
						break;					
					case LoadState.LOAD_FAILED:
						_smilFileLoadState = "Load FAILED";
						break;
					case LoadState.CONSTRUCTED:
						if (event.oldState == LoadState.UNLOADING)
						{
							_smilFileLoadState = "Not Loaded";
						}
						else
						{
							_smilFileLoadState = "Constructed";
						}
						break;
					case LoadState.UNLOADING:
						_smilFileLoadState = "Unloading";
						break;
				}
			}
			
			private function onSwitchingChange(event:SwitchingChangeEvent):void
			{
				var msg:String = "Switching change "
				var showCurrentIndex:Boolean = false;
				
				switch(event.newState)
				{
					case SwitchingChangeEvent.SWITCHSTATE_COMPLETE:
						msg += "COMPLETE";
						showCurrentIndex = true;
						break;
					case SwitchingChangeEvent.SWITCHSTATE_FAILED:
						msg += "FAILED";
						break;
					case SwitchingChangeEvent.SWITCHSTATE_REQUESTED:
						msg += "REQUESTED";
						break;

				}
				
				if (event.detail != null)
				{
					msg += ", " + event.detail.description + ". " + event.detail.moreInfo;
				}
				
				debug(msg);
				
				if (showCurrentIndex)
				{
					var streamMsg:String = "Current streaming profile index: " + _switchable.currentIndex + " of " + _switchable.maxIndex;
					debug(streamMsg);
					
					streamMsg = "Current bitrate = " + _switchable.getBitrateForIndex(_switchable.currentIndex) + "kbps";
					debug(streamMsg);
				}
				
				updateSwitchingControls();
			}
			
			private function updateSwitchingControls():void
			{				
				// Disable if a switch is pending or the video is not switchable
				if (_switchable == null || _switchable.switchUnderway)
				{
					autoSwitchBtn.enabled = false;
					switchUpBtn.enabled = false;
					switchDownBtn.enabled = false;
				}
				else if (!_switchable.autoSwitch)
				{
					autoSwitchBtn.enabled = true;
					switchUpBtn.enabled = (_switchable.currentIndex == _switchable.maxIndex) ? false : true;
					switchDownBtn.enabled = (_switchable.currentIndex == 0) ? false : true;
				}
				else
				{
					autoSwitchBtn.enabled = true;
					switchUpBtn.enabled = false;
					switchDownBtn.enabled = false;
				}
			}
			
			private function debug(...args):void
			{
				var lineNo:int = currentDebugLineNo++;
				taDebug.text += lineNo + ":" + args + "\n";
				callLater(autoScroll);
			}

			private function autoScroll():void 
			{
				taDebug.verticalScrollPosition = taDebug.maxVerticalScrollPosition;
			}

			private function createDynamicStreamingElement(res:IMediaResource):void
			{	
				clearDebugText();
								
				var mediaElement:VideoElement = new VideoElement(new DynamicStreamingNetLoader(), res);
				mediaElement.addEventListener(MediaErrorEvent.MEDIA_ERROR, onMediaError);
				
				var loadable:ILoadable = mediaElement.getTrait(MediaTraitType.LOADABLE) as ILoadable;
				loadable.addEventListener(LoadableStateChangeEvent.LOADABLE_STATE_CHANGE, onLoadableStateChange);
									
				wrapper.element = mediaElement;
				wrapper.mediaPlayer.autoPlay = true;
			}
			
			private function clearDebugText():void
			{
				taDebug.text = "";
				currentDebugLineNo = 0;			
			}
			
			private function clear(eraseDebugTxt:Boolean=true):void
			{
				if (eraseDebugTxt)
				{
					clearDebugText();
				}
				//wrapper.width = 640;
				//wrapper.height = 360;
			}
			
			private function unload():void
			{
				var mediaElement:MediaElement = wrapper.element;
				if (mediaElement != null && mediaElement.hasTrait(MediaTraitType.LOADABLE))
				{
					var loadable:ILoadable = mediaElement.getTrait(MediaTraitType.LOADABLE) as ILoadable;
					if (loadable.loadState == LoadState.LOADED)
					{
						loadable.unload();
					}
				}
				clear(false);
			}			
			
			protected function onSwitchableChange(event:Event):void
			{
				_switchable = wrapper.element.getTrait(MediaTraitType.SWITCHABLE) as ISwitchable;

				if (_switchable != null)
				{
					setupCustomSwitchable();
				}				
			}
			
			private function setupCustomSwitchable():void
			{
				_switchable.addEventListener(SwitchingChangeEvent.SWITCHING_CHANGE, onSwitchingChange);
				/*
				Uncomment to start in manual mode.
				_switchable.autoSwitch = false;
				_autoswitchBtnLabel = "Auto";
				_isAutoSwitchable = false;
				*/
			}
						
			private function load():void
			{
				clear();
								
				if (cbMediaURL.selectedItem is MediaElement)
				{
					wrapper.element = MediaElement(cbMediaURL.selectedItem);
					wrapper.mediaPlayer.addEventListener(MediaPlayerCapabilityChangeEvent.SWITCHABLE_CHANGE, onSwitchableChange);
					_switchable = wrapper.element.getTrait(MediaTraitType.SWITCHABLE) as ISwitchable;

					if (_switchable != null)
					{
						setupCustomSwitchable();						
					}
					
					var loadable:ILoadable = wrapper.element.getTrait(MediaTraitType.LOADABLE) as ILoadable;
					loadable.addEventListener(LoadableStateChangeEvent.LOADABLE_STATE_CHANGE, onLoadableStateChange);
					
					wrapper.mediaPlayer.autoPlay = true;
				}				
				else if (cbMediaURL.text.search(/\.smil$/i) == -1)
				{
					// This sample player can handle "regular" content as well
					this.createDynamicStreamingElement(new URLResource(new FMSURL(smilURL)));
					return;
				}
				else
				{
					var smilURL:String = cbMediaURL.text as String;
					
					_smilParser = new SMILParser();
					
					_smilParser.addEventListener(SMILParser.PARSED, onSMILParsed, false, 0, true);
					_smilParser.addEventListener(SMILParser.ERROR, onSMILParseError, false, 0, true);
					_smilParser.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onSMILSecurityError, false, 0, true);
					_smilParser.addEventListener(SMILParser.BUSY, onSMILParserBusy, false, 0, true);
					
					_smilParser.load(smilURL);	
				}	
			}
			
			private function onSMILParsed(e:Event):void
			{
				var dynamicStreamingResource:DynamicStreamingResource = _smilParser.dynamicStreamingResource;
				this.createDynamicStreamingElement(dynamicStreamingResource);
				
			}
			
			private function onSMILParseError(e:IOErrorEvent):void
			{
				Alert.show("SMIL parsing error: " + e.toString());
			}
			
			private function onSMILSecurityError(e:SecurityErrorEvent):void
			{
				Alert.show("SMIL parsing security error: " + e.toString());
			}
			
			private function onSMILParserBusy(e:Event):void
			{
				Alert.show("SMIL parser is currently busy, pleast wait and try again.");	
			}
			
			private function onDimensionChange(event:DimensionChangeEvent):void 
			{
				
			}
			
			private function onDurationChange(event:DurationChangeEvent):void
			{
				seekBar.maximum = event.newDuration;
				lblDuration.text = timeCode(event.newDuration);
				seekBar.enabled = seekBar.visible = wrapper.mediaPlayer.seekable;
				
			}
						
			private function onPlayheadChange(event:PlayheadChangeEvent):void
			{
				if (wrapper.mediaPlayer.temporal && !sliderDragging && !waitForSeek) {
					seekBar.value = event.newPosition;
					lblPlayhead.text = timeCode(event.newPosition);
				}
			}
			
			private function onSeekingChange(event:SeekingChangeEvent):void
			{
				if (!event.seeking)
				{
					waitForSeek = false;
					updateSwitchingControls();
				}
			}

   			private function toggleDragging(state:Boolean):void {
   				sliderDragging = state;
   				if (!state) {
   					waitForSeek = true;
   					if (wrapper.mediaPlayer.seekable)
   					{
   						wrapper.mediaPlayer.seek(seekBar.value); 
   					}
   				}
   			}
   			   			
   			private function onMediaError(event:MediaErrorEvent):void
   			{
   				if (taDebug.text.length)
   				{
   					taDebug.text += "\n";
   				}
   				taDebug.text += taDebug.text + "error code="+event.error.errorCode+" description="+event.error.description;
   			}
   			
			private function timeCode(sec:Number):String 
			{
				var h:Number = Math.floor(sec/3600);
				h = isNaN(h) ? 0 : h;
				
				var m:Number = Math.floor((sec%3600)/60);
				m = isNaN(m) ? 0 : m;
				
				var s:Number = Math.floor((sec%3600)%60);
				s = isNaN(s) ? 0 : s;
				
				return (h == 0 ? "":(h<10 ? "0"+h.toString()+":" : h.toString()+":"))+(m<10 ? "0"+m.toString() : m.toString())+":"+(s<10 ? "0"+s.toString() : s.toString());
			}
   			
			private function onSwitchUp():void
			{
				if (_switchable && !_switchable.autoSwitch && !_switchable.switchUnderway)
				{
					var max:int = _switchable.maxIndex;
					if (_switchable.currentIndex < max)
					{
						_switchable.switchTo(_switchable.currentIndex + 1);
					}
				}
				
			}
			
			private function onSwitchDown():void
			{
				if (_switchable && !_switchable.autoSwitch && !_switchable.switchUnderway)
				{
					if (_switchable.currentIndex > 0)
					{
						_switchable.switchTo(_switchable.currentIndex - 1);
					}
				}				
			}
			
			private function onAutoSwitchable():void
			{
				if (_switchable)
				{
					this._isAutoSwitchable = !this._isAutoSwitchable;
					_switchable.autoSwitch = this._isAutoSwitchable; 
					debug("Setting auto switch mode to "+ this._isAutoSwitchable);
					
					_autoswitchBtnLabel = (_isAutoSwitchable ? "Manual" : "Auto");
					updateSwitchingControls();
				}
			}
			
			private function onClickPlayBtn():void
			{
				if (wrapper.mediaPlayer.playing && wrapper.mediaPlayer.pausable)
				{
					playBtn.label = "Play";
					wrapper.mediaPlayer.pause();
				}
				else if (wrapper.mediaPlayer.paused && wrapper.mediaPlayer.playable)
				{
					playBtn.label = "Pause";
					wrapper.mediaPlayer.play();
				}
			}
						
			private function showControls(show:Boolean=true):void
			{
				mainContainer.visible = mainContainer.includeInLayout = show;
			}
						
		]]>
	</mx:Script>

	<examples:Compositions id="creator" />
	<mx:VBox id="mainContainer" height="100%" width="100%" paddingLeft="10" paddingTop="10">
		<mx:Label text="OSMF Dynamic Streaming Sample App" styleName="title" width="100%" textAlign="left" paddingLeft="20"/>
		<mx:Spacer height="20" />
		<mx:HBox id="inputContainer" height="60">
			<mx:Spacer width="10" />
			<mx:ComboBox id="cbMediaURL" editable="true" dataProvider="{creator.comps}" />
			<mx:Button label="Load" click="{load()}"/>
			<mx:Button label="Unload" click="{unload()}"/>
			<mx:Label text="{_smilFileLoadState}"/>
		</mx:HBox>	

		<mx:Spacer height="5" />
		<mx:HBox width="100%"
			height="100%">
			<mx:VBox id="videoContainer" 
				width="100%"
				height="100%"
				paddingLeft="20">
				<mx:Spacer width="10" />
				
				<players:MediaPlayerWrapper id="wrapper" width="100%" height="100%"  />				
				
			    <mx:VBox id="controlsContainer">
		    		<mx:HSlider id="seekBar" width="100%" thumbPress="toggleDragging(true)" thumbRelease="toggleDragging(false)" />
		    		<mx:HBox horizontalAlign="right" width="100%">
	    				<mx:Label text="Position: " />
						<mx:Label id="lblPlayhead" width="100" styleName="timeCode" />
						<mx:Label text="Duration: " />
		    			<mx:Label id="lblDuration" width="100" styleName="timeCode" />			
						<mx:Button id="playBtn" label="Pause" click="onClickPlayBtn()" enabled="{wrapper.mediaPlayer.playable}" />
						<mx:Button id="autoSwitchBtn" label="{_autoswitchBtnLabel}" click="onAutoSwitchable()" enabled="{_switchable!=null}" />
						<mx:Button id="switchUpBtn" label="+" click="onSwitchUp()" enabled="false" />
						<mx:Button id="switchDownBtn" label="-" click="onSwitchDown()" enabled="false" />
	    			</mx:HBox>
				</mx:VBox>	    						
			</mx:VBox>
			<mx:Spacer width="20" />
			<mx:VBox id="debugContainer">
				<mx:TextArea id="taDebug" wordWrap="false" editable="false" width="640" height="360"/>
			</mx:VBox>			
		</mx:HBox>
	</mx:VBox>
</mx:Application>
